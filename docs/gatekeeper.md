# Gatekeeper -> k8s-ai-bench Task Recipe

This doc is a practical recipe for turning Gatekeeper suites into k8s-ai-bench tasks. It focuses on:
- the step-by-step conversion
- the exact transformations we apply (and why)
- what goes into the prompt
- how repair works

Everything described here is implemented in `scripts/gatekeeper-taskgen/`.

## The Recipe (End to End)

1) **Start with Gatekeeper suites**
   - `suite.yaml` is the source of truth for which cases are compliant vs violating.
   - Each `tests[]` entry becomes one k8s-ai-bench task.

2) **Classify cases**
   - Any case with `violations: true | "yes" | >0` -> **beta** (violating)
   - Otherwise -> **alpha** (compliant)
   - If a test has only alpha or only beta cases, skip it.

3) **Rewrite and emit artifacts**
   - Each case object is rewritten and saved under `artifacts/` as alpha/beta.
   - Inventory objects (if present) are rewritten and saved under `artifacts/inventory-*`.

4) **Write task wrapper files**
   - `task.yaml` with the generated prompt and expected outputs
   - `setup.sh` and `cleanup.sh`
   - `suite.yaml` copied for `gator verify`
   - `constraint.yaml` rewritten for isolation
   - `template.yaml` copied as-is

5) **(Optional) Verify and repair**
   - `gator verify` for semantic correctness
   - `--repair` to fix alpha/beta alignment using Gemini

## Transformations (What We Change and Why)

### 1) Namespaces and identity
- Namespaced objects are forced into `gk-<taskID>`.
- Cluster-scoped objects have no namespace.
- Every object gets label `k8s-ai-bench/task: <taskID>`.

Why: task isolation and stable selection across tasks.

### 2) Name obfuscation
- We rename objects to `resource-001`, `resource-002`, etc. (unique per kind+namespace).
- If the template explicitly checks `metadata.name`, we preserve the original name for **beta** cases only.

Why: prevents models from guessing violations based on names, while preserving name-sensitive policies.

### 3) Deployability filters
We drop objects that are not deployable in a real cluster:
- `AdmissionReview` objects (not a real Kubernetes resource)
- Pods with `ephemeralContainers` (not allowed on create)
- Pods with duplicate container names (invalid schema)

Why: benchmark tasks must be runnable with `kubectl apply`.

### 4) Deployability fixes
We patch known patterns that would stall or fail unrelated to policy intent:
- Init containers that would hang are made to exit quickly
- Known bad images are replaced with safe tags

Why: avoids flakiness that is not policy-related.

### 5) Resource normalization (unless policy is about resources)
We minimize cpu/memory requests and limits to reduce noise:
- cpu: `1m`
- memory: `1Mi`

We skip normalization for resource-specific constraints such as:
- `K8sContainerLimits`
- `K8sContainerRequests`
- `K8sContainerRatios`
- `K8sRequiredResources`
- `K8sContainerEphemeralStorageLimit`

Why: keeps non-resource policies focused, while preserving signal for resource policies.

### 6) Inventory objects
Inventory objects are context, not targets:
- rewritten like normal resources
- original names preserved
- applied before alpha/beta

Why: some policies require external state (e.g., uniqueness constraints).

### 7) Constraint rewrite
Constraints are copied verbatim except:
- If `spec.match.namespaces` exists and is non-empty, we replace it with `["gk-<taskID>"]`.
- We scrub leaking labels (`k8s-ai-bench/expected`, `k8s-ai-bench/task`).

Why: keep constraints scoped to the isolated test namespace.

## What Goes Into the Prompt

Prompts are generated by Gemini in `prompt.go`. We pass:
- Template metadata: `metadata.gatekeeper.sh/title` and `description`
- Rewritten constraint YAML (namespace aligned)
- A compliant example (alpha) and a violating example (beta)
- The namespace (if any) and the resource kinds present

The prompt is instructed to:
- describe the policy in natural language
- ask for violating resource names
- use a strict output format:

```
VIOLATING: <resource name>
```

If the task only includes cluster-scoped kinds, the prompt omits the namespace.

## Repair: Making Alpha/Beta Clean

`--repair` uses Gemini to fix artifacts in place when alpha/beta separation is weak.
Each repair prompt includes:
- the constraint YAML
- the template YAML (if present)
- the target manifest
- strict rules: keep name/namespace/labels, do not change kind/apiVersion/container names
- minimal resource values whenever possible

Outputs are normalized (resources/replicas) and written back.
A `repair-report.md` is generated with diffs for every modified manifest.

